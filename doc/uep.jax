*UEP.jax* For UEP.nvim                          vim: ft=help

==============================================================================
目次                                                     *UEP-contents*

  1. はじめに..................................... |UEP-introduction|
  2. 使い方....................................... |UEP-usage|
     - コマンド一覧............................... |UEP-commands-list|
     - コマンド詳細............................... |UEP-commands-detail|
  3. 設定......................................... |UEP-configuration|
     - セットアップ............................... |UEP-setup|
     - プロジェクト固有の設定 (.unlrc.json)....... |UEP-unlrc|
     - フルコンフィグ............................. |UEP-default-configuration|
  4. Lua API...................................... |UEP-api|
  5. 連携サンプル (neo-tree)...................... |UEP-integration-examples|
  6. ライセンス................................... |UEP-license|

==============================================================================
1. はじめに                                         *UEP-introduction*

UEP.nvim (Unreal Engine Project Explorer) は、Unreal Engineプロジェクトの
構造を理解し、ナビゲートするために設計されたNeovimプラグインです。

プロジェクト全体のモジュールとファイル情報を非同期で解析・キャッシュすることで、
UIをブロックすることなく、非常に高速でインテリジェントなファイルナビゲーション
体験を提供します。

これは *Unreal Neovim Plugin Stack* の中核をなすプラグインであり、基盤ライブ
ラリとして UNL.nvim に依存しています。

主な機能:
- 高速な非同期キャッシング:
  ゲームとエンジンモジュールの情報をバックグラウンドでスキャンし、キャッシュ
  します。複数のプロジェクトでエンジンキャッシュを共有することも可能です。
- 強力なファイル検索:
  モジュールのスコープ（Game/Engine/Runtime/Editor/Full）や依存関係
  （shallow/deep）を指定して、プロジェクト内のファイルを瞬時に検索できます。
  モジュール、Programs、Configファイルに特化した検索コマンドも利用可能です。
- UI抽象化レイヤー:
  Telescope, fzf-lua, またはNeovim標準UIを、環境に応じて自動で選択・使用
  します。
- 拡張性の高いAPI:
  `neo-tree`のようなファイラープラグインと簡単に連携できます。

==============================================================================
2. 使い方                                                     *UEP-usage*

UEP.nvim のコマンドはすべて `:UEP` から始まります。

------------------------------------------------------------------------------
コマンド一覧                                           *UEP-commands-list*

:UEP refresh [Game|Engine]
  プロジェクトのキャッシュを更新します。
:UEP files[!] [Game|Engine|Runtime|Editor|Full] [--no-deps|--shallow-deps|--deep-deps]
  日常的に使うソースや設定ファイルをUIで検索します。
:UEP module_files[!] [ModuleName]
  指定したモジュールに属するファイルを検索します。
:UEP program_files
  Programsディレクトリ内のファイルを検索します。
:UEP grep [Game|Engine|Runtime|Editor|Full]
  プロジェクトまたはエンジン全体からLiveGrepします。
:UEP module_grep [ModuleName]
  特定のモジュール内をLiveGrepします。
:UEP program_grep
  Programsディレクトリ内のファイルをLiveGrepします。
:UEP config_grep [Game|Engine|Full]
  .ini 設定ファイル内をLiveGrepします。
:UEP open_file [Path]
  プロジェクトキャッシュを検索して、インクルードファイルを開きます。
:UEP add_include[!] [ClassName]
  クラスの#includeディレクティブを検索し、挿入します。
:UEP find_derived[!] [ClassName]
  指定した基底クラスの全ての派生クラスを検索します。
:UEP find_parents[!] [ClassName]
  指定したクラスの継承チェーンを検索します。
:UEP classes[!] [Game|Engine|Runtime|Editor|Full] [--no-deps|--shallow-deps|--deep-deps]
  指定したスコープ内のC++クラスを検索します。
:UEP structs[!] [Game|Engine|Runtime|Editor|Full] [--no-deps|--shallow-deps|--deep-deps]
  指定したスコープ内のC++構造体を検索します。
:UEP enums[!] [Game|Engine|Runtime|Editor|Full] [--no-deps|--shallow-deps|--deep-deps]
  指定したスコープ内のC++ Enum（列挙型）を検索します。
:UEP purge [ComponentName]
  特定のコンポーネントのファイルキャッシュのみを削除します。
:UEP cleanup
  現在のプロジェクトの全ての構造キャッシュとファイルキャッシュを削除します。
:UEP tree [Game|Engine|Runtime|Editor|Full] [--no-deps|--shallow-deps|--deep-deps]
  プロジェクト全体の論理ツリーを表示します。(neo-tree-unl.nvim が必要)
:UEP module_tree [ModuleName] [--no-deps|--shallow-deps|--deep-deps]
  特定のモジュールにフォーカスした論理ツリーを表示します。(neo-tree-unl.nvim が必要)
:UEP cd
  既知のプロジェクト一覧から移動先を選択します。
:UEP delete
  既知のプロジェクト一覧からプロジェクトを削除します。
:UEP goto_definition[!] [ClassName]
  先行宣言をスキップして、クラスや構造体の実際の定義ファイルにジャンプします。
:UEP system_open[!] [Path]
  ファイルの場所をシステムエクスプローラーで開きます。
:UEP config_files
  すべてのコンフィグファイル (.ini) を検索します。
:UEP shaders[!] [Scope]
  シェーダーファイル (.usf, .ush) を検索します。
:UEP close_tree
  UEPツリーを閉じ、展開状態のキャッシュをクリアします。
:UEP goto_super_def
  現在の関数の親クラス定義へジャンプします。
:UEP goto_super_impl
  現在の関数の親クラス実装へジャンプします。
:UEP implement_virtual [ClassName]
  親クラス階層から仮想関数をオーバーライドします。
:UEP find_module[!]
  クラスが所属するモジュール名を検索し、クリップボードにコピーします。
:UEP build_cs[!]
  現在のモジュールのBuild.csを開きます。[!]で全モジュールから選択します。
:UEP target_cs[!]
  Target.csを開きます。[!]でエンジンを含めた全ターゲットから選択します。
:UEP web_doc[!]
  Unreal EngineのWebドキュメントを検索します。

------------------------------------------------------------------------------
コマンド詳細                                           *UEP-commands-detail*

:UEP refresh [Game|Engine]
    現在のプロジェクトをスキャンし、モジュールとファイルのキャッシュを更新しま
    す。このプラグインで最も重要なコマンドです。
    - `[Game|Engine]`: (省略可、デフォルト: `Game`)
      - `Game`: 現在のゲームプロジェクトのモジュールのみスキャンします。
                関連するエンジンのキャッシュが存在しない場合は、先にエンジン
                のスキャンが自動的に実行されます。
      - `Engine`: 関連するエンジンのモジュールのみをスキャンします。

:UEP files[!] [Game|Engine|Runtime|Editor|Full] [--no-deps|--shallow-deps|--deep-deps]
    キャッシュされた情報に基づいて、ファイル検索UIを開きます。
    - `[!](bang)`: (省略可)
      `!`を付けると、キャッシュを強制的に再生成してからUIを開きます。
    - `[Game|...|Full]`: (省略可、デフォルト: `runtime`)
      検索のベースとなるモジュールのスコープを指定します。
    - `[--no-deps|...]`: (省略可、デフォルト: `--deep-deps`)
      - `--no-deps`: ベーススコープのモジュールのみを検索対象とします。
      - `--shallow-deps`: 直接の依存関係にあるモジュールを検索対象に含めます。
      - `--deep-deps`: ベーススコープのモジュールが依存する全てのモジュール
                       （推移的依存関係を含む）を検索対象とします。

:UEP module_files[!] [ModuleName]
    特定のモジュールに属するファイル一覧を表示します。
    - `[!](bang)`: (省略可)
      `!`を付けると、指定したモジュールのファイルリストのみを軽量に更新
      してからファイル一覧を表示します。
    - `[ModuleName]`: (省略可)
      省略した場合、全モジュールを選択するUIが開き、選択後にそのモジュー
      ルのファイルが表示されます。

:UEP program_files
    プロジェクトとエンジンに関連する全てのProgramsディレクトリ
    （例: UnrealBuildTool, AutomationTool）内のファイルを検索します。

:UEP config_files
    プロジェクトとエンジンに関連するすべてのコンフィグファイル (.ini) を検索
    します。

:UEP shaders[!] [Scope]
    指定されたスコープ内のシェーダーファイル (.usf, .ush) を検索します。
    - `[!](bang)`: (省略可) キャッシュを強制的に再生成します。
    - `[Scope]`: (省略可、デフォルト: `Full`) `Game`, `Engine`, `Full` など。

:UEP grep [Game|Engine|Runtime|Editor|Full]
    プロジェクトとエンジンのソースコード全体からLiveGrepします (rgが必須)。
    - `[Game|...|Full]`: (省略可、デフォルト: `runtime`)
      - `Game`: あなたのプロジェクトのソースファイルとプラグインのみを検索します。
      - `Engine`: 関連付けられたエンジンのソースコード**のみ**を検索します。
      - `Full` / `Runtime` / `Editor` / `Developer`: プロジェクトとエンジン
        の両方を検索します。

:UEP module_grep [ModuleName]
    特定のモジュールのディレクトリ内に限定してLiveGrepします。
    - `[ModuleName]`: (省略可) 省略した場合、モジュールを選択するUIが開きます。

:UEP program_grep
    プロジェクトとエンジンに関連する全てのProgramsディレクトリ内のファイルを
    LiveGrepします。ビルドツールや自動化スクリプトのコードを調査する際に
    便利です。

:UEP config_grep [Game|Engine|Full]
    `.ini` 設定ファイル内をLiveGrepします。
    - `[Game|Engine|Full]`: (省略可、デフォルト: `runtime` で `Full` と同様)
      - `Game`: プロジェクトの `Config/` ディレクトリのみを検索します。
      - `Engine`: エンジンの `Config/` ディレクトリのみを検索します。
      - `Full` / `Runtime` / etc.: プロジェクトとエンジンの両方を検索します。

:UEP open_file [Path]
    インクルードパスに基づいてファイルを検索し、開きます。
    - `[Path]`: (省略可) 検索対象のインクルードパス。省略した場合、現在の行
      のテキスト（例: `"`...`"` や `<`...`>` 内）からパスを抽出します。
      以下の優先順位でインテリジェントに検索されます:
      1. 現在のファイルがあるディレクトリからの相対パス。
      2. 現在のモジュールの Public/Private ディレクトリからの相対パス。
      3. 現在のモジュールの浅い依存関係および深い依存関係内。
      4. プロジェクトキャッシュ全体（フォールバック）。

:UEP add_include[!] [ClassName]
    プロジェクトキャッシュに基づいて、C++クラスの正しい#includeディレクティブを
    検索し、挿入します。
    - `[!](bang)`: (省略可)
      `!`を付けると、引数やカーソル下の単語を無視し、プロジェクト全体の
      クラスからインクルードするクラスを選択するためのピッカーUIを開きます。
    - `[ClassName]`: (省略可) インクルードするクラス名。省略された場合は、
      カーソル下の単語 (`<cword>`) が使用されます。
    このコマンドは、以下のルールでインテリジェントにディレクティブを挿入します:
      - ヘッダーファイル(`.h`)の場合: `.generated.h` の行の前。
      - ソースファイル(`.cpp`)の場合: 既存の最後の `#include` 文の後。

:UEP purge [ComponentName]
    指定されたコンポーネント（Game/Engine/Plugin）の**ファイルキャッシュ**
    （`*.files.json`）のみを削除します。
    このコマンドは非同期で実行され、実行には確認が必要です。

:UEP cleanup
    危険: 現在のプロジェクトに関連する**全て**の構造キャッシュ 
    （`*.project.json`）および**全て**のファイルキャッシュ（`*.files.json`）を
    永久に削除します（プラグインやリンクされたエンジンも含む）。
    このコマンドはプログレスバーを表示しながら非同期で実行され、実行には確認が
    必要です。実行後、キャッシュを再構築するために**必ず** |:UEP refresh| を
    実行してください。

:UEP find_derived[!] [ClassName]
    指定した基底クラスを継承する全てのクラスを検索します。
    - `[!](bang)`: (省略可) `!`を付けると、引数を無視し、基底クラスを
      選択するピッカーUIを開きます。
    - `[ClassName]`: (省略可) 省略した場合、カーソル下の単語 (`<cword>`)
      が使用されます。

:UEP find_parents[!] [ClassName]
    指定したクラスから `UObject` に至るまでの継承チェーンを表示します。
    - `[!](bang)`: (省略可) `!`を付けると、引数を無視し、起点となるクラス
      を選択するピッカーUIを開きます。
    - `[ClassName]`: (省略可) 省略した場合、カーソル下の単語 (`<cword>`)
      が使用されます。

:UEP classes[!] [Game|Engine|Runtime|Editor|Full] [--no-deps|--shallow-deps|--deep-deps]
    C++クラスの定義を選択し、ジャンプするためのピッカーを表示します。
    - 使い方: |:UEP files| と同様に動作し、スコープと依存関係の深さに
      基づいて、既知のシンボルリストをフィルタリングします。
    - `[Game|...|Full]`: (省略可、デフォルト: `runtime`) 検索のベース
      となるモジュールのスコープを指定します。
    - `[--no-deps|...]`: (省略可、デフォルト: `--deep-deps`)
      - `--no-deps`: 指定されたスコープのモジュール内のみを検索します。
      - `--shallow-deps`: 直接の依存関係にあるモジュールを含めます。
      - `--deep-deps`: 依存関係にある全てのモジュールを検索対象に含めます。

:UEP structs[!] [Game|Engine|Runtime|Editor|Full] [--no-deps|--shallow-deps|--deep-deps]
    C++構造体の定義を選択し、ジャンプするためのピッカーを表示します。
    - 使い方: |:UEP classes| と全く同じ挙動をします。
    - `[Game|...|Full]`: (省略可、デフォルト: `runtime`)
    - `[--no-deps|...]`: (省略可、デフォルト: `--deep-deps`)

:UEP enums[!] [Game|Engine|Runtime|Editor|Full] [--no-deps|--shallow-deps|--deep-deps]
    C++ Enum（列挙型）の定義を選択し、ジャンプするためのピッカーを表示します。
    - 使い方: |:UEP classes| と全く同じ挙動をします。
    - `[Game|...|Full]`: (省略可、デフォルト: `runtime`)
    - `[--no-deps|...]`: (省略可、デフォルト: `--deep-deps`)

:UEP tree [Game|Engine|Runtime|Editor|Full] [--no-deps|--shallow-deps|--deep-deps]
    neo-treeで論理的なプロジェクトエクスプローラーを開きます。
    neo-tree-unl.nvim が必要です。ビューにはGame、Plugins、Engineの
    コンポーネントが含まれます。
    - `[Game|...|Full]`: (省略可、デフォルト: `runtime`) スコープを制御します。
    - `[--no-deps|...]`: (省略可、デフォルト: `--deep-deps`) 表示される
      依存モジュールを制御します。

:UEP module_tree [ModuleName] [--no-deps|--shallow-deps|--deep-deps]
    単一のモジュールまたはその依存関係にフォーカスした論理ツリーを開きます。
    neo-tree-unl.nvim が必要です。
    - `[ModuleName]`: (省略可) 省略した場合、モジュールを選択するUIが開きます。
    - `[--no-deps|...]`: (省略可、デフォルト: `--deep-deps`) 依存関係の表示
      を制御します。

:UEP cd
    キャッシュされている既知のプロジェクト一覧をUIで表示し、選択したプロジェ
    クトのルートディレクトリにカレントディレクトリを変更します。

:UEP delete
    既知のプロジェクト一覧をUIで表示し、選択したプロジェクトを一覧から削除し
    ます。実際のプロジェクトファイルは削除されません。

:UEP goto_definition[!] [ClassName]
    先行宣言をスキップして、クラスの実際の定義ファイルにジャンプします。
    - `[!](bang)`: (省略可)
     `!`を付けると、引数やカーソル下の単語を無視し、プロジェクト全体の
      クラスからジャンプ先を選択するためのピッカーUIを開きます。
    - `[ClassName]`: (省略可) ジャンプしたいクラス名。省略された場合は、
      カーソル下の単語 (`<cword>`) が使用されます。
    このコマンドは、現在のモジュールの依存関係（現在のコンポーネント ->
    浅い依存 -> 深い依存）に基づいてインテリジェントな階層的検索を実行し、
    見つからなければLSPにフォールバックします。

:UEP system_open[!] [Path]
    指定されたファイルの場所をOSのファイルエクスプローラーで開きます。
    - `[!](bang)`: (省略可)
      `!`を付けると、プロジェクトキャッシュ全体からファイルを選択する
      ピッカーUIを開きます。
    - `[Path]`: (省略可)
      省略した場合、現在のバッファのファイルがあるディレクトリを開きます。

:UEP close_tree
    neo-treeウィンドウを（開いていれば）閉じ、UEPが内部で保持しているノード
    の展開状態キャッシュをクリアします。次回ツリーを開く際に、全て折りたたま
    れた状態から開始されます。

:UEP goto_super_def
    現在カーソルがある関数の、親クラスにおける定義（ヘッダーファイル）へ
    ジャンプします。キャッシュされたプロジェクトデータを使用して、継承
    チェーンをインテリジェントに解決します。

:UEP goto_super_impl
    親クラスにおける関数の実装（ソースファイル）へジャンプします。
    ソースファイルが見つからない場合は、ヘッダー定義へフォールバックします。

:UEP implement_virtual [ClassName]
    親クラスの階層からオーバーライド可能な仮想関数をリストアップします。
    関数を選択すると、ヘッダーファイルに宣言を自動挿入し、実装スタブを
    クリップボードにコピーします。ヘッダーファイル内で実行する必要があります。

:UEP find_module[!]
    プロジェクト全体のクラス、構造体、Enumを選択するためのピッカーUIを開き
    ます。項目を選択すると、そのシンボルが所属しているモジュール名（例：
    `"Core"`, `"UMG"`）をダブルクォーテーション付きでクリップボードにコピー
    します。`Build.cs` の編集に便利です。

:UEP build_cs[!]
    - `!`なし: 現在編集中のファイルが属するモジュールの `Build.cs` を即座
      に開きます。モジュールが特定できない場合はピッカーを表示します。
    - `!`あり: プロジェクト内の全ての `Build.cs` をリストアップし、選択
      して開きます。

:UEP target_cs[!]
    - `!`なし: 現在のプロジェクトに含まれる `Target.cs` をリストアップし、
      選択して開きます。
    - `!`あり: エンジン側の `Target.cs` も含めた全てのターゲットをリスト
      アップし、選択して開きます。

:UEP web_doc[!]
    ブラウザでUnreal Engineの公式ドキュメントを開きます。
    - `!`なし: カーソル下の単語を検索します。
    - `!`あり: プロジェクト内のクラス一覧から選択して開きます。

==============================================================================
3. 設定                                           *UEP-configuration*

UEP.nvim の設定は、依存ライブラリである UNL.nvim の設定システムを通じて
行われます。

------------------------------------------------------------------------------
セットアップ                                                  *UEP-setup*

`lazy.nvim`を使っている場合、`opts`キーに設定テーブルを渡します。`UEP.nvim`
の `dependencies` に `UNL.nvim` を指定することが必須です。

例:
>lua
  return {
    'taku25/UEP.nvim',
    dependencies = { 'taku25/UNL.nvim' },
    opts = {
      -- UNL.nvimを通じてUEPの設定を行う
      files_extensions = { "cpp", "h", "hpp", "inl", "ini", "cs", "uproject" },
      ui = {
        picker = { mode = "telescope" },
      },
    },
  }
<

利用可能なオプションの詳細は |UEP-default-configuration| を参照してください。

------------------------------------------------------------------------------
プロジェクト固有の設定 (.unlrc.json)                      *UEP-unlrc*

プロジェクトのルートディレクトリに`.unlrc.json`という名前のJSONファイルを作成
することで、グローバルな設定をそのプロジェクトでのみ上書きできます。この機能は
UNL.nvim によって提供されています。

例:
>json
  {
    "files_extensions": [ "cpp", "h", "ini", "cs", "md" ]
  }
<

------------------------------------------------------------------------------
フルコンフィグ                               *UEP-default-configuration*

以下は、*UEP.nvim* に関連する設定可能なすべてのオプションと、そのデフォルト値
です。これらの設定は UNL.nvim の設定テーブルの一部として扱われます。

>lua
{
  -- ':UEP refresh' コマンドによってスキャンされるファイルの拡張子
  files_extensions = {
    "cpp", "h", "hpp", "inl", "ini", "cs",
  },

  -- エンジンの自動検出が失敗する場合に、手動でパスを指定します
  -- 例: "C:/Program Files/Epic Games/UE_5.4"
  engine_path = nil,

  -- UIバックエンドの設定 (UNL.nvimから継承)
  ui = {
    picker = {
      mode = "auto", -- "auto", "telescope", "fzf_lua", "native"
      prefer = { "telescope", "fzf_lua", "native" },
    },
    progress = {
      enable = true,
      mode = "auto", -- "auto", "fidget", "window", "notify"
      prefer = { "fidget", "window", "notify" },
    },
  },
}
<

==============================================================================
4. Lua API                                                     *UEP-api*

`UEP.nvim`は、外部連携のためにシンプルなAPIを提供します。コマンドと同様の機能
をLuaから直接呼び出すことができます。

APIモジュールを`require`する:
>lua
  local uep_api = require("UEP.api")
<

*uep_api.refresh({opts})*
    キャッシュを更新します。
    `opts`テーブル:
      - `type` (string, optional): `"Game"` または `"Engine"`。

*uep_api.files({opts})*
    ファイル検索UIを開きます。
    `opts`テーブル:
      - `has_bang` (boolean, optional): `true`でキャッシュを強制更新。
      - `scope` (string, optional): `"Game"`, `"Engine"`, `"runtime"`など。
      - `deps_flag` (string, optional): `"--deep-deps"`, `"--shallow-deps"`など。

*uep_api.module_files({opts})*
    モジュールファイル検索UIを開きます。
    `opts`テーブル:
      - `has_bang` (boolean, optional): `true`でモジュールキャッシュを軽量更新。
      - `module_name` (string, optional): モジュール名を直接指定。

*uep_api.program_files({opts})*
    プログラムファイル検索UIを開きます。optsは現在使用されません。

*uep_api.grep({opts})*
    LiveGrepのUIを開きます。optsでscope ("Game", "Engine", "runtime"など)
    を指定できます。

*uep_api.module_grep({opts})*
    特定モジュールのLiveGGrep UIを開きます。optsでmodule_nameを指定できます。

*uep_api.program_grep({opts})*
    Programsディレクトリを対象としたLiveGrep UIを開きます。optsは現在使用
    されません。

*uep_api.config_grep({opts})*
    .iniファイル用のLiveGrep UIを開きます。
    `opts`でscope ("Game", "Engine", "runtime"など) を指定できます。

*uep_api.tree({opts})*
    論理プロジェクトツリーを開きます。optsでscopeとdeps_flagを指定できます。

*uep_api.module_tree({opts})*
    論理モジュールツリーを開きます。optsでmodule_nameとdeps_flagを
    指定できます。

*uep_api.cd({opts})*
    プロジェクト選択UIを開きます。optsは現在使用されません。

*uep_api.delete({opts})*
    プロジェクト削除UIを開きます。optsは現在使用されません。


*uep_api.open_file({opts})*
    インテリジェント検索を使い、インクルードファイルを開きます。
    `opts`テーブル:
      - `path` (string, optional): 検索対象のインクルードパス。省略した
        場合、現在の行から抽出されます。

*uep_api.add_include({opts})*
    プログラムで#includeディレクティブを挿入します。
    `opts`テーブル:
      - `has_bang` (boolean, optional): `true`でピッカーUIを強制的に開きます。
      - `class_name` (string, optional): インクルードしたいクラス名。

*uep_api.goto_definition({opts})*
    先行宣言をスキップし、依存関係を検索して、クラスの定義ファイルへ
    インテリジェントにジャンプします。
    `opts`テーブル:
      - `has_bang` (boolean, optional): `true`でクラスピッカーUIを
        強制的に開きます。
      - `class_name` (string, optional): ジャンプしたいクラス名。省略し
        `has_bang`が`false`の場合、カーソル下の単語を使用します。

*uep_api.system_open({opts})*
    システムエクスプローラーを開きます。
    `opts`テーブル:
      - `has_bang` (boolean, optional): `true`でファイルピッカーUIを
        強制的に開きます。
      - `path` (string, optional): 開く対象のファイルパス。

*uep_api.config_files({opts})*
    コンフィグファイル検索UIを開きます。optsは現在使用されません。

*uep_api.shaders({opts})*
    シェーダーファイル検索UIを開きます。
    `opts`テーブル:
      - `has_bang` (boolean, optional): `true`でキャッシュを強制更新。
      - `scope` (string, optional): `"Game"`, `"Engine"`, `"Full"`など。

*uep_api.close_tree({opts})*
    ツリーを閉じ、展開状態をクリアします。optsは現在使用されません。

*uep_api.goto_super_def({opts})*
    親クラスの定義へジャンプします。optsは現在使用されません。

*uep_api.goto_super_impl({opts})*
    親クラスの実装へジャンプします。optsは現在使用されません。

*uep_api.implement_virtual({opts})*
    仮想関数オーバーライドのフローを開始します。
    `opts`テーブル:
      - `class_name` (string, optional): コンテキストとなるクラス名。

*uep_api.find_module({opts})*
    シンボルのモジュール名を検索します。
    `opts`テーブル:
      - `has_bang` (boolean, optional): `true`でキャッシュを強制更新。

*uep_api.build_cs({opts})*
    Build.csを開きます。
    `opts`テーブル:
      - `has_bang` (boolean, optional): `true`で全モジュールから選択。

*uep_api.target_cs({opts})*
    Target.csを開きます。
    `opts`テーブル:
      - `has_bang` (boolean, optional): `true`でEngineターゲットを含める。

*uep_api.web_doc({opts})*
    Webドキュメントを開きます。
    `opts`テーブル:
      - `has_bang` (boolean, optional): `true`でクラスピッカーを使用。
      - `query` (string, optional): 検索クエリ。

==============================================================================
5. 連携サンプル (neo-tree)                 *UEP-integration-examples*

`UEP.api` を使うことで、`neo-tree`から直接UEP.nvimの機能を呼び出すことが
できます。

例: neo-treeのキーマッピング設定
>lua
  -- ... (neo-treeのセットアップ) ...
  filesystem = {
    window = {
      mappings = {
        -- <leader>pf でプロジェクトファイル検索UIを開く
        ["<leader>pf"] = function(state)
          local node = state.tree:get_node()
          local path = node.type == "directory" and node.path or vim.fs.dirname(node.path)
          -- APIを呼ぶ前にCWDをプロジェクト内に設定
          vim.api.nvim_set_current_dir(path)
          require("UEP.api").files({})
        end,
        -- <leader>pt でモジュールをファイラーで開く
        ["<leader>pt"] = function(state)
          local node = state.tree:get_node()
          local path = node.type == "directory" and node.path or vim.fs.dirname(node.path)
          vim.api.nvim_set_current_dir(path)
          require("UEP.api").tree({})
        end,
      },
    },
  },
  -- ...
<

==============================================================================
6. ライセンス                                                *UEP-license*

MIT License

Copyright (c) 2025 taku25

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
==============================================================================
 vim:tw=78:ts=8:ft=help:norl:
